<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NFL — This Week's TD Scorers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --text:#111; --muted:#666; --rule:#eee;
    }
    body { font: 16px system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 2rem; color: var(--text); }
    h1 { margin: .25rem 0 .5rem }
    #stamp { color: var(--muted); margin-bottom: 1rem }
    .small { color: var(--muted); font-size: .9em }
    ul { list-style: none; padding: 0; margin: 0 }
    li { padding: .5rem 0; border-bottom: 1px solid var(--rule); display: flex; align-items: center; gap: .6rem; }
    .logo { width: 28px; height: 28px; object-fit: contain; flex: 0 0 28px; }
    .row { display: flex; flex-direction: column; }
    .line { display: inline-block; }
    #status { margin: .5rem 0 1rem; }
    #attrib {
      background: #f6f6f6; border: 1px solid var(--rule); padding: 8px 12px; border-radius: 8px;
      font-size: .9em; color: var(--muted); margin-bottom: 12px;
    }
    #attrib a { color: inherit; text-decoration: underline; }
  </style>
</head>
<body>
  <div id="attrib">Data source: ESPN public score APIs (unofficial/open endpoints).</div>

  <h1>TD Scorers — Current Week</h1>
  <div id="stamp" class="small"></div>
  <div id="status">Loading…</div>
  <ul id="list"></ul>

  <script>
  (async function () {
    const status = document.getElementById('status');
    const list = document.getElementById('list');
    const stamp = document.getElementById('stamp');

    // Build a map of team -> logo from the scoreboard payload (no hardcoding)
    const teamMetaById = new Map();     // id -> {abbr, logo}
    const teamMetaByAbbr = new Map();   // abbr -> {abbr, logo}

    function tdCategory(p) {
      const txt = (p.text || '').toLowerCase();
      const players = Array.isArray(p.players) ? p.players : [];
      const types = players.map(x => (x && x.type && x.type.text ? x.type.text.toLowerCase() : '')).join(' ');

      if (/receive|reception|receiver/.test(types)) return 'Receiving';
      if (/rush|rusher|run/.test(types)) return 'Rushing';
      if (/kickoff return|punt return|returner/.test(types)) return 'Return';
      if (/interception/.test(types)) return 'INT Return';
      if (/fumble/.test(types)) return 'Fumble Return';

      if (/(pass|from)/.test(txt) && !/interception/.test(txt)) return 'Receiving';
      if (/\brun|\brush|\bkeeper/.test(txt)) return 'Rushing';
      if (/kickoff return|punt return/.test(txt)) return 'Return';
      if (/interception.*return|pick[- ]?six/.test(txt)) return 'INT Return';
      if (/fumble.*return|fumble.*recovery/.test(txt)) return 'Fumble Return';

      return 'TD';
    }

    try {
      // 1) Current week's games
      const scoreboardUrl = 'https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard';
      const sb = await fetch(scoreboardUrl).then(r => r.json());
      const events = Array.isArray(sb.events) ? sb.events : [];
      if (!events.length) throw new Error('No games this week (yet).');

      // Extract team meta (abbr + logo) from the scoreboard once
      for (const ev of events) {
        const comp = ev?.competitions?.[0];
        const comps = comp?.competitors || [];
        for (const c of comps) {
          const t = c?.team;
          if (!t) continue;
          const id = t.id, abbr = t.abbreviation;
          // ESPN often provides a 'logo' field or 'logos' array; prefer the square one if present
          const logo = (t.logos && t.logos[0]?.href) || t.logo || null;
          if (id && abbr) {
            if (!teamMetaById.has(id)) teamMetaById.set(id, { abbr, logo });
            if (!teamMetaByAbbr.has(abbr)) teamMetaByAbbr.set(abbr, { abbr, logo });
          }
        }
      }

      // 2) Pull each game's summary and aggregate TDs
      const byPlayer = new Map(); // key -> { total, byType: {...}, logo, abbr }
      const seenPlays = new Set();

      function addTD(name, teamAbbr, logoUrl) {
        const key = `${name} (${teamAbbr})`;
        if (!byPlayer.has(key)) byPlayer.set(key, { total: 0, byType: {}, logo: logoUrl || '', abbr: teamAbbr });
        const row = byPlayer.get(key);
        row.total += 1;
        return row;
      }

      async function processEvent(ev) {
        const id = ev.id || (ev.uid && ev.uid.split('~').pop());
        if (!id) return;
        const summaryUrl = `https://site.api.espn.com/apis/site/v2/sports/football/nfl/summary?event=${id}`;
        const data = await fetch(summaryUrl).then(r => r.json());
        const plays = Array.isArray(data.scoringPlays) ? data.scoringPlays : [];
        for (const p of plays) {
          const unique = p.id || `${id}:${p.clock && p.clock.displayValue}:${p.text}`;
          if (seenPlays.has(unique)) continue;
          seenPlays.add(unique);

          const isTD = String(p.type && p.type.text || '').toLowerCase().includes('touchdown')
                       || /\btd\b|touchdown/.test((p.text || '').toLowerCase());
          if (!isTD) continue;

          const teamId = p.team?.id, teamAbbr = p.team?.abbreviation || '';
          const meta = (teamId && teamMetaById.get(teamId)) || teamMetaByAbbr.get(teamAbbr) || { abbr: teamAbbr, logo: '' };
          const cat = tdCategory(p);

          const players = Array.isArray(p.players) ? p.players : [];
          const primary = players.find(x =>
            x && x.type && /scorer|rush|receive|return|interception|fumble/i.test(x.type.text || '')
          );

          let row;
          if (primary?.athlete?.displayName) {
            row = addTD(primary.athlete.displayName, meta.abbr || teamAbbr, meta.logo);
          } else {
            const m = /([A-Z][\w.\-'\s]+)\s+\d+\s*(yd|yard)/i.exec(p.text || '');
            row = addTD(m ? m[1].trim() : 'Unknown', meta.abbr || teamAbbr, meta.logo);
          }

          // bump the category count
          const k = cat;
          row.byType[k] = (row.byType[k] || 0) + 1;
        }
      }

      // Gentle concurrency (6 summaries at a time)
      for (let i = 0; i < events.length; i += 6) {
        await Promise.all(events.slice(i, i + 6).map(processEvent));
      }

      // 3) Render
      const rows = [...byPlayer.entries()]
        .sort((a, b) => b[1].total - a[1].total)
        .map(([label, info]) => {
          const breakdown = Object.entries(info.byType)
            .sort((a,b)=> b[1]-a[1])
            .map(([k,v]) => `${k.replace(' Return',' Ret')}: ${v}`)
            .join(', ');

          const logo = info.logo ? `<img class="logo" src="${info.logo}" alt="${info.abbr} logo" loading="lazy">` : `<span class="logo" aria-hidden="true"></span>`;

          return `<li>${logo}<span class="row">
              <span class="line"><strong>${label}</strong> — ${info.total} TD${info.total>1?'s':''}</span>
              ${breakdown ? `<span class="line small">[${breakdown}]</span>` : ''}
            </span></li>`;
        });

      list.innerHTML = rows.join('') || '<li>No TDs recorded yet.</li>';
      status.textContent = '';
      stamp.textContent = `Last fetched: ${new Date().toLocaleString()}`;
    } catch (err) {
      console.error(err);
      status.textContent = 'Could not load TD scorers.';
    }
  })();
  </script>
</body>
</html>
